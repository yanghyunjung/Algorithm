### 1. 백준 2579번 계단오르기
- Dynamic Programming(동적 프로그래밍)은 하나의 문제는 단 한번만 풀도록 하는 알고리즘이다.   
   #### __``Why? 왜 쓰이나``__ 한번 푼 것을 여러 번 다시 푸는 비효율적인 알고리즘을 개선시키는 방법이다.   
   DP에서는 '메모이제이션(Memoization)'이 사용된다는 점에 분할 정복과 다르다. _이미 계산한 결과는 배열에 저장함_ 으로써 나중에 동일한 계산을 해야 할 때는 저장된 값을 단순히 반환하기만 하면 되는 것이다.
- 파이썬으로 배열을 입력 받아야 한다면 append 함수를 쓰는 게 효율적이다    
   #### __``Why? 왜 쓰이나``__ C언어와 다르게 Python에서는 가장 뒤에 원소를 추가하는 게 시간 복잡도가 __O(1)__ 이기 때문이다.   
__Tip!__ 마지막 계단은 무조건 밟아야 하므로 뒤에서부터 계산하면 편할 듯!    
     소스 코드를 참고해서 봤지만 그래도 이해가 안됐던 문제ㅠ   
     __내일 다시 풀어보기!__   

   
### 2. 백준 4673번 셀프넘버   
- 중복되지 않은 원소(unique)를 얻고자 set(집합) 함수를 이용해서 풀어보자 -> key가 없고 값만 존재한다.   
- set(집합)함수는 순서대로 정렬이 되지 않기 때문에 sorted를 이용해서 정렬했다!
  ```
  self_num = sorted(natural_num-generated_num)
  for i in self_num:
    print(i)   
  ```   
  
### 3. 백준 4949번 균형잡힌세상   
- 일단 "([" 가 ")]"보다 먼저 나와야 한다는 걸 기억하자!    
![1](https://user-images.githubusercontent.com/57293780/122596125-61dcb400-d0a4-11eb-8600-7a1b5e3d733e.PNG)   
- 주석처리 한 부분을 보면 스택 배열에 ")"나 "]" 앞에  "("나 "[" 문자열이 포함되어 있는지 확인해줘야한다.   
   포함한다면 True, 포함하지 않는다면 False!

---    
### 동적 프로그래밍, BFS & DFS 다시 훑기    
   계단오르기가 동적 프로그래밍을 사용하기 때문에 다시 훑어보기!   
   내일 풀 문제에 BFS랑 DFS도 포함되어 있는 것 같아 얘네도 다시 개념 정리하기! 
