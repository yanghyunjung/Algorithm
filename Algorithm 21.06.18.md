#### 1. 백준 2579번 계단오르기
- Dynamic Programming(동적 프로그래밍)은 하나의 문제는 단 한번만 풀도록 하는 알고리즘이다.   
   #### __``Why?``__ 한번 푼 것을 여러 번 다시 푸는 비효율적인 알고리즘을 개선시키는 방법이다.   
   DP에서는 '메모이제이션(Memoization)'이 사용된다는 점에 분할 정복과 다르다. _이미 계산한 결과는 배열에 저장함_ 으로써 나중에 동일한 계산을 해야 할 때는 저장된 값을 단순히 반환하기만 하면 되는 것이다.
- 파이썬으로 배열을 입력 받아야 한다면 append 함수를 쓰는 게 효율적이다   
   #### __``Why?``__ C언어와 다르게 Python에서는 가장 뒤에 원소를 추가하는 게 시간 복잡도가 __O(1)__ 이기 때문이다.   
   
#### 2. 백준 4673번 셀프넘버   
- 중복되지 않은 원소(unique)를 얻고자 set(집합) 함수를 이용해서 풀어보자 -> key가 없고 값만 존재한다.   
- set(집합)함수는 순서대로 정렬이 되지 않기 때문에 sorted를 이용해서 정렬했다!
  ```
  self_num = sorted(natural_num-generated_num)
  for i in self_num:
    print(i)
  ```   

#### 3. 백준 2579번 계단오르기    
Tip! 마지막 계단은 무조건 밟아야 하므로 뒤에서부터 계산하면 편할 듯!    
     소스 코드를 참고했지만 이해가 잘 되지 않았다   
     __내일 다시 풀어보기!__   

### + 동적 프로그래밍, BFS & DFS 다시 훑기   
